****************** Card for Message writing with Send and receive Button ******************

// Message Input Card with Hex Support
            Card(
                modifier = Modifier.fillMaxWidth(),
                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
            ) {
                Column(
                    modifier = Modifier.padding(6.dp),
                    verticalArrangement = Arrangement.spacedBy(4.dp)
                ) {
                    // Mode Switch
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text("Input Mode:")
                        Switch(
                            checked = isHexMode,
                            onCheckedChange = {
                                isHexMode = it
                                // Clear inputs when switching modes
                                currentMessage = ""
                                hexInput = ""
                            }
                        )
                        Text(if (isHexMode) "HEX" else "TEXT")
                    }

                    if (isHexMode) {
                        // Hex Input Field
                        OutlinedTextField(
                            value = hexInput,
                            onValueChange = { input ->
                                if (isValidHex(input)) {
                                    hexInput = input.uppercase()
                                }
                            },
                            label = { Text("Hex Value (e.g., FF 00 A1)") },
                            modifier = Modifier.fillMaxWidth(),
                            colors = OutlinedTextFieldDefaults.colors(
                                focusedBorderColor = MaterialTheme.colorScheme.primary,
                                unfocusedBorderColor = MaterialTheme.colorScheme.outline
                            ),
                            isError = hexInput.isNotEmpty() && !isValidHex(hexInput)
                        )
                        // Helper text for hex input
                        Text(
                            "Enter hex values separated by spaces",
                            style = MaterialTheme.typography.bodySmall,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    } else {
                        // Regular text input
                        OutlinedTextField(
                            value = currentMessage,
                            onValueChange = { currentMessage = it },
                            label = { Text("Text Message") },
                            modifier = Modifier.fillMaxWidth()
                        )
                    }

                    // Send Button Row
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.spacedBy(4.dp)
                    ) {
                        Button(
                            onClick = {
                                scope.launch(Dispatchers.IO) {
                                    try {
                                        if (isHexMode) {
                                            if (hexInput.isNotEmpty() && isValidHex(hexInput)) {
                                                val hexBytes = hexToByteArray(hexInput)
                                                bluetoothSocket?.outputStream?.write(hexBytes)
                                                messageLog.add("Sent HEX: $hexInput")
                                                hexInput = "" // Clear after sending
                                            }
                                        } else {
                                            if (currentMessage.isNotEmpty()) {
                                                val messageBytes = currentMessage.toByteArray()
                                                bluetoothSocket?.outputStream?.write(messageBytes)
                                                messageLog.add("Sent TEXT: $currentMessage")
                                                currentMessage = "" // Clear after sending
                                            }
                                        }
                                    } catch (e: IOException) {
                                        messageLog.add("Send failed: ${e.message}")
                                    }
                                }
                            },
                            enabled = connectionState && (
                                    (isHexMode && hexInput.isNotEmpty() && isValidHex(hexInput)) ||
                                            (!isHexMode && currentMessage.isNotEmpty())
                                    ),
                            modifier = Modifier.weight(1f)
                        ) {
                            Text("Send ${if (isHexMode) "HEX" else "TEXT"}")
                        }

                        Button(
                            onClick = {
                                scope.launch(Dispatchers.IO) {
                                    try {
                                        isReading = !isReading
                                        val buffer = ByteArray(1024)

                                        // Continue reading while connected
                                        while (isReading && bluetoothSocket?.isConnected == true) {
                                            val bytesAvailable = bluetoothSocket?.inputStream?.available() ?: 0

                                            if (bytesAvailable > 0) {
                                                val bytes = bluetoothSocket?.inputStream?.read(buffer) ?: 0
                                                if (bytes > 0) {
                                                    // Convert to text
                                                    val receivedMessage = String(buffer, 0, bytes)
                                                    // Convert to hex
                                                    val hexValue = buffer.take(bytes).joinToString(" ") { "%02X".format(it) }

                                                    withContext(Dispatchers.Main) {
                                                        messageLog.add("Received: $receivedMessage")
                                                        messageLog.add("Hex: $hexValue")
                                                    }
                                                }
                                            }
                                            // Add small delay to prevent CPU overuse
                                            delay(100)
                                        }
                                    } catch (e: IOException) {
                                        withContext(Dispatchers.Main) {
                                            messageLog.add("Receive failed: ${e.message}")
                                        }
                                    } finally {
                                        isReading = false
                                    }
                                }
                            },
                            enabled = connectionState,
                            modifier = Modifier.weight(1f),
                            colors = ButtonDefaults.buttonColors(
                                containerColor = if (isReading)
                                    MaterialTheme.colorScheme.error
                                else MaterialTheme.colorScheme.secondary
                            )
                        ) {
                            Text(
                                if (isReading) "Stop Reading" else "Start Reading",
                                textAlign = TextAlign.Center,
                                modifier = Modifier.fillMaxWidth()
                            )
                        }

//                        // Quick Hex Buttons
//                        if (isHexMode) {
//                            val quickHexValues = listOf("FF", "00", "A5")
//                            quickHexValues.forEach { hex ->
//                                OutlinedButton(
//                                    onClick = {
//                                        hexInput = if (hexInput.isEmpty()) hex
//                                        else "$hexInput $hex"
//                                    },
//                                    modifier = Modifier.weight(1f)
//                                ) {
//                                    Text(hex)
//                                }
//                            }
//                        }
                    }
                }
            }




************* Message Log Code ********************

// Message Log Section
            Card(
                modifier = Modifier
                    .fillMaxWidth()
                    .height(300.dp),
                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
            ) {
                Column(
                    modifier = Modifier.padding(16.dp)
                ) {
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(
                            "Message Log",
                            style = MaterialTheme.typography.titleMedium
                        )
                        Row(
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Switch(
                                checked = autoScroll,
                                onCheckedChange = { autoScroll = it }
                            )
                            Text(
                                "Auto-scroll",
                                modifier = Modifier.padding(start = 4.dp),
                                style = MaterialTheme.typography.bodySmall
                            )
                        }
                    }

                    Spacer(modifier = Modifier.height(8.dp))

                    val listState = rememberLazyListState()

                    LaunchedEffect(messageLog.size) {
                        if (autoScroll && messageLog.isNotEmpty()) {
                            listState.animateScrollToItem(messageLog.size - 1)
                        }
                    }

                    LazyColumn(
                        state = listState,
                        modifier = Modifier
                            .fillMaxWidth()
                            .weight(1f)
                            .border(
                                1.dp,
                                Color.White,
                                MaterialTheme.shapes.small
                            )
                            .padding(8.dp)
                    ) {
                        items(messageLog) { message ->
                            MessageLogItem(message)
                        }
                    }
                }
            }


****************** New ConnectBLActivity File (27/02/2025) *************************

package com.example.bleconnect

import BluetoothPermissionHandler
import android.annotation.SuppressLint
import android.app.Activity
import android.bluetooth.BluetoothAdapter
import android.bluetooth.BluetoothDevice
import android.bluetooth.BluetoothGatt
import android.bluetooth.BluetoothGattCallback
import android.bluetooth.BluetoothGattCharacteristic
import android.bluetooth.BluetoothGattDescriptor
import android.bluetooth.BluetoothManager
import android.bluetooth.BluetoothProfile
import android.bluetooth.BluetoothSocket
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.util.Log
import android.widget.Toast
import androidx.activity.compose.BackHandler
import androidx.compose.animation.AnimatedContent
import androidx.compose.animation.animateContentSize
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.lazy.rememberLazyListState
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.rounded.CheckCircle
import androidx.compose.material.icons.rounded.Edit
import androidx.compose.material.icons.rounded.Info
import androidx.compose.material.icons.rounded.Lock
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.OutlinedTextFieldDefaults
import androidx.compose.material3.Surface
import androidx.compose.material3.Switch
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.DisposableEffect
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateListOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.input.ImeAction
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.input.PasswordVisualTransformation
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import com.example.bleconnect.classic.ClassicBluetoothManager
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import kotlinx.coroutines.withTimeout
import java.io.IOException
import java.util.UUID

@SuppressLint("MissingPermission")
@Composable
fun ConnectGATTSample(onBack: () -> Unit) {
    var selectedDevice by rememberSaveable() {
        mutableStateOf<BluetoothDevice?>(null)
    }

    BackHandler {
        onBack()
    }
    var showBluetoothPermissionHandler by remember {
        mutableStateOf(false)
    }
    val classicBluetoothManager = remember { ClassicBluetoothManager() }

    if (showBluetoothPermissionHandler) {
        BluetoothPermissionHandler(
            onPermissionGranted = {
                showBluetoothPermissionHandler = false
            },


            )
    }

    RememberBluetoothStateListener(
        onBluetoothDisabled = {
            showBluetoothPermissionHandler = true
        }
    )

    AnimatedContent(targetState = selectedDevice, label = "Selected device") { device ->
        if (device == null) {
            FindDevicesScreen(onClose = { showBluetoothPermissionHandler = true } ){
                if (classicBluetoothManager.isBluetoothAvailableAndEnabled()) {
                    selectedDevice = it
                } else {
                    showBluetoothPermissionHandler = true
                }
            }
        } else {
            if (classicBluetoothManager.isBluetoothAvailableAndEnabled()) {
                ConnectDeviceScreen(
                    device = device,
                    onClose = { selectedDevice = null }
                )
                Log.i("ConnectGATTSample", "ConnectGATTSample: ConnectDeviceScreen called successfully!")
            } else {
                // Instead of just showing a Toast, we show the permission handler
                Log.e("ConnectGATTSample", "Bluetooth not Enabled!")
                showBluetoothPermissionHandler = true
            }
        }
    }
}



// Optional: Add a utility function to check Bluetooth state changes
@Composable
fun RememberBluetoothStateListener(
    onBluetoothDisabled: () -> Unit
) {
    val context = LocalContext.current

    DisposableEffect(context) {
        val receiver = object : BroadcastReceiver() {
            override fun onReceive(context: Context?, intent: Intent?) {
                if (intent?.action == BluetoothAdapter.ACTION_STATE_CHANGED) {
                    val state = intent.getIntExtra(
                        BluetoothAdapter.EXTRA_STATE,
                        BluetoothAdapter.ERROR
                    )
                    if (state == BluetoothAdapter.STATE_OFF) {
                        onBluetoothDisabled()
                    }
                }
            }
        }

        context.registerReceiver(
            receiver,
            IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED)
        )

        onDispose {
            context.unregisterReceiver(receiver)
        }
    }
}


@SuppressLint("InlinedApi", "MissingPermission")
@Composable
fun ConnectDeviceScreen(
    device: BluetoothDevice,
    onClose: () -> Unit
) {
    val context = LocalContext.current

    // Check if the device is a Classic Bluetooth device or BLE
    when (device.type) {
        BluetoothDevice.DEVICE_TYPE_CLASSIC -> {
            // Classic Bluetooth (SPP / HC-05)
            Toast.makeText(context, "Detected Classic Bluetooth Device!", Toast.LENGTH_LONG).show()
            Log.i("BluetoothCheck", "Device is Classic Bluetooth (SPP)")
            ConnectHC05DeviceScreen(device = device, onClose = onClose)
        }

        BluetoothDevice.DEVICE_TYPE_LE, BluetoothDevice.DEVICE_TYPE_DUAL -> {
            // BLE Device (JDY-23 or Other BLE modules)
            Toast.makeText(context, "Detected BLE Device!", Toast.LENGTH_LONG).show()
            Log.i("BluetoothCheck", "Device is BLE")
            ConnectJDY23DeviceScreen(device = device, onClose = onClose)
        }

        else -> {
            // Unknown Device Type
            Toast.makeText(context, "Unknown Bluetooth Type!", Toast.LENGTH_LONG).show()
            Log.e("BluetoothCheck", "Unknown device type: ${device.type}")
        }
    }
}

// Helper function to convert hex string to byte array
fun hexToByteArray(hexString: String): ByteArray {
    val hex = hexString.replace(" ", "")
    val bytes = ByteArray(hex.length / 2)

    for (i in bytes.indices) {
        bytes[i] = hex.substring(i * 2, i * 2 + 2).toInt(16).toByte()
    }
    return bytes
}

@SuppressLint("MissingPermission")
@Composable
fun ConnectHC05DeviceScreen(device: BluetoothDevice, onClose: () -> Unit) {

    BackHandler {
        // Do nothing when the back button is pressed
    }

    val scope = rememberCoroutineScope()

    // State to track whether to show the table screen
    var showTableScreen by remember { mutableStateOf(false) }

    // Get the Activity context from LocalContext
    val activity = LocalContext.current as? Activity

    val context = LocalContext.current

    // Keeps track of the connection state
    var connectionState by remember { mutableStateOf(false) }

    // Keeps track of the messages sent and received
    val messageLog = remember { mutableStateListOf<String>() }

    // Bluetooth socket for communication
    var bluetoothSocket: BluetoothSocket? by remember { mutableStateOf(null) }

    var isCheckingConnection by remember { mutableStateOf(false) }

    var autoScroll by remember { mutableStateOf(true) }

    val classicBluetoothManager = remember { ClassicBluetoothManager() }

    var isReading by remember { mutableStateOf(false) }
    var currentMessage by remember { mutableStateOf("") }
    // New state variables for hex input
    var hexInput by remember { mutableStateOf("") }
    var isHexMode by remember { mutableStateOf(false) }
    // Validation function for hex input
    fun isValidHex(input: String): Boolean {
        return input.matches(Regex("^[0-9A-Fa-f\\s]*$"))
    }

////    ******Unpair and disconnect Bl device*******
//    fun disconnectAndUnpair() {
//        try {
//            // Close Bluetooth socket if it exists
//            bluetoothSocket?.let { socket ->
//                try {
//                    socket.close()
//                } catch (e: IOException) {
//                    Log.e("Bluetooth", "Error closing socket: ${e.message}")
//                }
//            }
//
//            // Get the BluetoothDevice object
//            device.let { device ->
//                // Remove bond (unpair)
//                try {
//                    val method = device.javaClass.getMethod("removeBond")
//                    method.invoke(device)
//
//                    // Update UI or show message
//                    messageLog.add("Device unpaired successfully")
//                } catch (e: Exception) {
//                    messageLog.add("Error unpairing device: ${e.message}")
//                    Log.e("Bluetooth", "Error unpairing device: ${e.message}")
//
//                }
//            }
//
//            // Reset connection state
//            bluetoothSocket = null
//            connectionState = false
//
//
//        } catch (e: Exception) {
//            Log.e("Bluetooth", "Error during disconnect: ${e.message}")
//        }
//    }
//


    // Theme colors for status
    val connectionColor = if (connectionState) MaterialTheme.colorScheme.primary
    else MaterialTheme.colorScheme.error

//    var isChangingPassword by remember { mutableStateOf(false) }



    var count = 0
    fun checkConnection(): Boolean {
        return try {

            bluetoothSocket?.let { socket ->
                if (socket.isConnected) {
                    count += 1
                    // Send a small ping to verify the connection
                    if(count == 3)
                    {
                        socket.outputStream?.write(0) // Attempt to write a single byte
                        count = 0
                    }
                    true
                } else {
                    false
                }
            } == true
        } catch (e: IOException) {
            Toast.makeText(context, "Connection Lost, Connect Again", Toast.LENGTH_LONG).show()
            false
        }
    }
//
//    fun crc_16bit_modbus(buffer: ByteArray): Int {
//        var crc = 0xFFFF
//
//        for (byte in buffer) {
//            crc = crc xor (byte.hashCode() and 0xFF)
//
//            repeat(8) {
//                crc = if (crc and 1 != 0) {
//                    (crc ushr 1) xor 0xA001
//                } else {
//                    crc ushr 1
//                }
//            }
//        }
//
//        return crc and 0xFFFF
//    }

//    fun changePassword() {
//        val buffer = ByteArray(1024)
//        scope.launch(Dispatchers.IO) {
//            try {
//                if (digitInput.length == 4 && isValidDigits(digitInput)) {
//
//                    val digitByte = digitInput.map {
//                        it.code.toByte()
//                    }
//
////                    ********** 3rd Way (Whole No. as Ascii Value) **********
////                    // Convert the entire input string to ASCII bytes
////                    val digitBytes = digitInput.map {
////                        it.code.toByte()  // This converts each character to its ASCII value
////                    }.toByteArray()
//
//
//
//                    // Calculate checksum
////                    val checksum = crc_16bit_modbus(digitBytes)
//
//                    // Convert to formatted hex string (12 83 AF 7A format)
//                    val hexString = StringBuilder()
//
//                    // Add header
//                    hexString.append("AB BA 31 ")
//
//                    // Convert the entire input to hex and split into pairs
//                    val number = digitInput.toInt()
//                    hexString.append(String.format("%02X %02X ",
//                        (number shr 8) and 0xFF,  // Gets "04"
//                        number and 0xFF           // Gets "D2"
//                    ))
//
//                    val digitBytes = hexString.map {
//                        it.code.toByte()  // This converts each character to its ASCII value
//                    }.toByteArray()
//
//                    val checksum = crc_16bit_modbus(digitBytes)
//
//                    messageLog.add("number: $number")
//                    messageLog.add("CheckSum: $checksum")
//
//
//                    // Add checksum as two separate bytes
////                    hexString.append(String.format("%02X ", (checksum ushr 8).toByte()))  // High byte
////                    hexString.append(String.format("%02X", checksum.toByte()))            // Low byte
//
//                    val finalHexString = hexString.toString()
//
//                    messageLog.add("Sending: ${(finalHexString)}")
//
//                    // Convert to byte array and send
//                    bluetoothSocket?.outputStream?.write(hexToByteArray(finalHexString))
//                    messageLog.add("Password Changed. Sent HEX: $finalHexString")
//
//                    // Clear input
//                    digitInput = ""
//                    delay(2000)
//                    disconnectAndUnpair()
//                    onClose()
//                }
//            } catch (e: IOException) {
//                messageLog.add("Password change failed: ${e.message}")
//            }
//        }
//    }

    fun connectToDevice() {
        scope.launch(Dispatchers.IO) {
            if (classicBluetoothManager.isBluetoothAvailableAndEnabled()) {
                try {
                    isCheckingConnection = true
                    messageLog.add("Attempting to connect to ${device.address}...")
                    val socket = device.createRfcommSocketToServiceRecord(
                        UUID.fromString("00001101-0000-1000-8000-00805F9B34FB")

                    )
                    withTimeout(10000) { socket.connect() }
                    bluetoothSocket = socket
                    connectionState = true
                    showTableScreen = true
                    messageLog.add("Successfully connected to ${device.address}")
                } catch (e: IOException) {
                    withContext(Dispatchers.Main) {
                        messageLog.add("Connection failed: ${e.message}")
                        bluetoothSocket?.close()
                        bluetoothSocket = null
                        connectionState = false
                    }
                } finally {
                    isCheckingConnection = false
                }
            }
        }
    }



    fun disconnectDevice() {
        scope.launch(Dispatchers.IO) {
            try {
                bluetoothSocket?.close()
                connectionState = false
                messageLog.add("Disconnected from ${device.address}")
            } catch (e: IOException) {
                messageLog.add("Disconnection failed: ${e.message}")
            }
        }
    }
//
//    fun sendAcknowledgePacket() {
//        if(checkConnection()){
//            scope.launch(Dispatchers.IO) {
//                try {
//                    val buffer = ByteArray(1024)
//                    val ackPacket = hexToByteArray("AB BB 39 00 00")
//                    bluetoothSocket?.outputStream?.write(ackPacket)
//
//                    val receivedData = mutableListOf<Byte>()
//                    val timeoutMillis = 5000L // Timeout in milliseconds
//                    val startTime = System.currentTimeMillis()
//
//                    while (System.currentTimeMillis() - startTime < timeoutMillis) {
//                        val bytesAvailable = bluetoothSocket?.inputStream?.available() ?: 0
//                        if (bytesAvailable > 0) {
//                            val bytesRead = bluetoothSocket?.inputStream?.read(buffer) ?: 0
//                            if (bytesRead > 0) {
//                                receivedData.addAll(buffer.take(bytesRead))
//                                val receivedHex = receivedData.joinToString(" ") { "%02X".format(it) }
//
//                                // Check if the received data matches the expected packet
//                                if (receivedHex.contains("AB BB 39 00 00")) {
//                                    showTableScreen = true
//                                    return@launch
//                                }
//                            }
//                        }
//                        delay(100) // Prevent busy-waiting
//                    }
//                }catch (e: IOException) {
//                    Toast.makeText(
//                        context,
//                        "Error during acknowledgment: ${e.message}",
//                        Toast.LENGTH_LONG
//                    ).show()
//                }
//            }
//        }else{
//            Toast.makeText(context, "Connection Lost, Connect again", Toast.LENGTH_LONG).show()
//            connectionState = false
//        }
//    }
//

    fun sendMessage() {
        scope.launch(Dispatchers.IO) {
            try {
                if (hexInput.isNotEmpty() && isValidHex(hexInput)) {
                    val hexBytes = hexToByteArray(hexInput)
                    bluetoothSocket?.outputStream?.write(hexBytes)
                    messageLog.add("Sent HEX: $hexInput")
                    hexInput = ""
                }
//                else {
//                    if (currentMessage.isNotEmpty()) {
//                        try {
//                            val decimalValue = currentMessage.toInt() // Convert string to integer
//                            val messageBytes = decimalValue.toString().toByteArray() // Convert integer to bytes
//                            bluetoothSocket?.outputStream?.write(messageBytes)
//                            messageLog.add("Sent DECIMAL: $decimalValue")
//                            currentMessage = "" // Clear after sending
//                        } catch (e: NumberFormatException) {
//                            messageLog.add("Error: Invalid number format")
//                        }
//                    }
//                }
            } catch (e: IOException) {
                messageLog.add("Send failed: ${e.message}")
            }
        }
    }

    fun toggleReadMessages() {
        scope.launch(Dispatchers.IO) {
            try {
                isReading = !isReading
                val buffer = ByteArray(1024)

                while (isReading && bluetoothSocket?.isConnected == true) {
                    val bytesAvailable = bluetoothSocket?.inputStream?.available() ?: 0

                    if (bytesAvailable > 0) {
                        val bytes = bluetoothSocket?.inputStream?.read(buffer) ?: 0
                        if (bytes > 0) {
                            val receivedMessage = String(buffer, 0, bytes)
                            val hexValue = buffer.take(bytes).joinToString(" ") { "%02X".format(it) }
                            withContext(Dispatchers.Main) {
                                messageLog.add("Received: $receivedMessage")
                                messageLog.add("Hex: $hexValue")
                            }
                        }
                    }
                    delay(100)
                }
            } catch (e: IOException) {
                withContext(Dispatchers.Main) {
                    messageLog.add("Receive failed: ${e.message}")
                }
            } finally {
                isReading = false
            }
        }
    }


    Column(
        modifier = Modifier
            .fillMaxSize()
            .verticalScroll(rememberScrollState()),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        Box(modifier = Modifier.fillMaxSize()) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .fillMaxSize()  // Take full size of parent
//                    .verticalScroll(rememberScrollState())  // Make column scrollable
                    .padding(16.dp),
                horizontalAlignment = Alignment.CenterHorizontally,
                verticalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                // Enhanced Header Section
                Card(
                    modifier = Modifier
                        .fillMaxWidth(),
                    elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
                ) {
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(6.dp),
                        horizontalArrangement = Arrangement.SpaceEvenly,  // Centers all content in the Box
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Column(
                            modifier = Modifier.padding(8.dp),
                            horizontalAlignment = Alignment.CenterHorizontally,
                        ) {
                            Text(
                                text = device.name ?: "Unknown Device",
                                style = MaterialTheme.typography.headlineMedium,
                                textAlign = TextAlign.Center
                            )
                            Text(
                                text = device.address,
                                style = MaterialTheme.typography.bodyMedium,
                                color = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                            Spacer(modifier = Modifier.height(8.dp))
                            Row(
                                verticalAlignment = Alignment.CenterVertically,
                                horizontalArrangement = Arrangement.Center
                            ) {
                                Box(
                                    modifier = Modifier
                                        .size(12.dp)
                                        .background(connectionColor, CircleShape)
                                )
                                Text(
                                    text = if (connectionState) "Connected" else "Disconnected",
                                    modifier = Modifier.padding(start = 8.dp),
                                    color = connectionColor,
                                    style = MaterialTheme.typography.bodyMedium
                                )
                            }
                        }
                    }
                }

                // Background connection checker
                LaunchedEffect(connectionState) {
                    scope.launch(Dispatchers.IO){
                        while (true) {
                            if (connectionState) {
                                val isStillConnected = checkConnection()
                                if (!isStillConnected && connectionState) {
                                    // Connection was lost
                                    connectionState = false
                                    messageLog.add("Connection lost. Device disconnected.")
                                    try {
                                        bluetoothSocket?.close()
                                    } catch (e: IOException) {
                                        // Ignore close errors
                                    }
                                    bluetoothSocket = null
                                }
                            }
                            delay(3000) // Check every second
                        }
                    }
                }

                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.Absolute.SpaceEvenly,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    // Connection Button
                    Button(
                        onClick = { if (connectionState) disconnectDevice() else connectToDevice() },
                        modifier = Modifier
                            .padding(10.dp)
                            .width(150.dp),
                        colors = ButtonDefaults.buttonColors(
                            containerColor = if (!connectionState) MaterialTheme.colorScheme.primary
                            else MaterialTheme.colorScheme.error
                        )
                    ) {
                        if (isCheckingConnection) {
                            CircularProgressIndicator(
                                modifier = Modifier.size(24.dp),
                                color = MaterialTheme.colorScheme.onPrimary
                            )
                        } else {
                            Text(text = if (connectionState) "Linked" else "Link")
                        }
                    }


//                    if(!settingCall){
//                        Button(
//                            onClick = { settingCall = true },
//                            modifier = Modifier
//                                .padding(10.dp)
//                                .width(150.dp),
//                            colors = ButtonDefaults.buttonColors(
//                                containerColor = MaterialTheme.colorScheme.primary
//                            ),
//                            enabled = connectionState
//
//                            ) {
//                            Row(
//                                modifier = Modifier.fillMaxWidth(),
//                                horizontalArrangement = Arrangement.Absolute.SpaceEvenly,
//                                verticalAlignment = Alignment.CenterVertically
//                            ) {
//                                Text(
//                                    text = "Settings",
//                                    color = Color.Unspecified,
//                                )
//                                Icon(Icons.Filled.Settings, contentDescription = "Settings")
//                            }
//                        }
//                    }
                }

//                if(settingCall){
//
//                    BasicAlertDialog(
//                        onDismissRequest = { settingCall = false },
//                        modifier = Modifier
//                            .fillMaxSize()
//                            .fillMaxWidth(),
//                        properties = DialogProperties(
//                            usePlatformDefaultWidth = false // This removes the default width constraint
//                        )
//                    ) {
//                        var selectedTab by remember { mutableIntStateOf(0) }
//                        val tabs = listOf("Password", "Device Name")
//
//                        Scaffold(
//                            topBar = {
//                                TopAppBar(
//                                    title = {
//                                        Text("Settings")
//                                    },
//                                    actions = {
//                                        // Header with Back Button
//                                        Row(
//                                            modifier = Modifier
//                                                .fillMaxWidth()
//                                                .padding(16.dp),
//                                            horizontalArrangement = Arrangement.Start,
//                                            verticalAlignment = Alignment.CenterVertically
//                                        ) {
//                                            IconButton(onClick = { settingCall = false }) {
//                                                Icon(Icons.Rounded.ArrowBackIosNew, "Back")
//                                            }
//                                            Text(
//                                                "Device Settings",
//                                                style = MaterialTheme.typography.headlineMedium
//                                            )
//
//                                        }
//                                    }
//                                )
//                            },
//                            bottomBar = { BottomAppBar {
//                                NavigationBarItem(
//                                    selected = currentRoute == "settings",
//                                    onClick = {
//
//                                    },
//                                    icon = { Icon(Icons.Filled.Settings, contentDescription = "Settings") },
//                                    label = { Text("Settings") }
//                                )
//                            } },
//                        ) { innerPadding ->
//                            Box(
//                                modifier = Modifier
//                                    .fillMaxSize()
//                                    .background(MaterialTheme.colorScheme.background)
//                                    .padding(innerPadding)
//                            ) {
//                                Column(
//                                    modifier = Modifier
//                                        .fillMaxSize()
//                                        .padding(16.dp)
//                                ) {
//
//
//                                    // Tabs
//                                    TabRow(
//                                        selectedTabIndex = selectedTab,
//                                        modifier = Modifier.fillMaxWidth()
//                                    ) {
//                                        tabs.forEachIndexed { index, title ->
//                                            Tab(
//                                                selected = selectedTab == index,
//                                                onClick = { selectedTab = index },
//                                                text = { Text(title) },
//                                                icon = {
//                                                    Icon(
//                                                        imageVector = when (index) {
//                                                            0 -> Icons.Rounded.Lock
//                                                            else -> Icons.Rounded.Edit
//                                                        },
//                                                        contentDescription = null
//                                                    )
//                                                }
//                                            )
//                                        }
//                                    }
//
//                                    // Content
//                                    Box(
//                                        modifier = Modifier
//                                            .verticalScroll(rememberScrollState())
//                                            .padding(vertical = 16.dp),
//
//                                        ) {
//                                        when (selectedTab) {
//                                            0 -> PasswordChangeContent(
//                                                digitInput = digitInput,
//                                                onDigitInputChange = {
//                                                    val filteredInput = it.filter { char -> char.isDigit() }
//                                                    digitInput = filteredInput.take(4)
//                                                },
//                                                connectionState = connectionState,
//                                                onChangePassword = { changePassword() }
//                                            )
//                                            1 -> DeviceNameContent(
//                                                deviceName = deviceName,
//                                                onDeviceNameChange = { deviceName = it },
//                                                connectionState = connectionState,
//                                                onUpdateDeviceName = {  }
//                                            )
//                                        }
//                                        // Back button
//                                        Button(
//                                            onClick = { settingCall = false },
//                                            modifier = Modifier.padding(top = 400.dp),
//
//                                            ){
//                                            Text(text = "Back")
//                                        }
//                                    }
//                                }
//                            }
//                        }
//                    }
//                }

                // Message Input Card with Hex Support
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
                ) {
                    Column(
                        modifier = Modifier.padding(6.dp),
                        verticalArrangement = Arrangement.spacedBy(4.dp)
                    ) {

                        // Mode Switch
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.SpaceBetween,
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Text("Input Mode:")
                            Switch(
                                checked = isHexMode,
                                onCheckedChange = {
                                    isHexMode = it
                                    // Clear inputs when switching modes
                                    currentMessage = ""
                                    hexInput = ""
                                }
                            )
                            Text(if (isHexMode) "HEX" else "TEXT")
                        }

                        if (isHexMode) {
                            // Hex Input Field
                            OutlinedTextField(
                                value = hexInput,
                                onValueChange = { input ->
                                    if (isValidHex(input)) {
                                        hexInput = input.uppercase()
                                    }
                                },
                                label = { Text("Hex Value (e.g., AB BB 00)") },
                                modifier = Modifier.fillMaxWidth(),
                                colors = OutlinedTextFieldDefaults.colors(
                                    focusedBorderColor = MaterialTheme.colorScheme.primary,
                                    unfocusedBorderColor = MaterialTheme.colorScheme.outline
                                ),
                                isError = hexInput.isNotEmpty() && !isValidHex(hexInput)
                            )
                            // Helper text for hex input
                            Text(
                                "Enter hex values separated by spaces",
                                style = MaterialTheme.typography.bodySmall,
                                color = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                        } else {
                            // Regular text input
                            OutlinedTextField(
                                value = currentMessage,
                                onValueChange = { currentMessage = it },
                                label = { Text("Text Message") },
                                modifier = Modifier.fillMaxWidth()
                            )
                        }

                        Column(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalAlignment = Alignment.CenterHorizontally,
                            verticalArrangement = Arrangement.Center
                        ) {
                            // Quick Hex Buttons
                            if (isHexMode) {
                                val quickHexValues = listOf(
                                    "AB BB 31 00 00",
                                    "AB BB 32 00 00",
                                    "AB BB 33 00 00",
                                    "AB BB 34 00 00",
                                    "AB BB 35 00 00",
                                    "AB BB 36 00 00",
                                    "AB BB 37 00 00",
                                    "AB BB 38 00 00",
                                    "AB BB 39 00 00",
                                    "AB BB 3A 00 00",
                                    "AB BB 3B 00 00",
                                    "AB BB 3C 00 00",
                                ) // Static hex values

                                quickHexValues.chunked(2).forEach { rowHexValues ->
                                    Row(
                                        modifier = Modifier.fillMaxWidth(),
                                        horizontalArrangement = Arrangement.SpaceEvenly
                                    ) {
                                        rowHexValues.forEach { hex ->
                                            OutlinedButton(
                                                onClick = {
                                                    // Add the clicked hex to hexInput
                                                    hexInput = if (hexInput.isEmpty()) hex else "$hexInput $hex"
                                                },
                                                modifier = Modifier.weight(1f)
                                            ) {
                                                Text(hex)
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        // Send Button Row
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.spacedBy(4.dp)
                        ) {
                            Button(
                                onClick = { sendMessage() },
//                                enabled = connectionState && hexInput.isNotEmpty() && isValidHex(hexInput),
//                                enabled = connectionState,
                                modifier = Modifier.weight(1f),
                            ) {
                                Text("Send HEX")
                            }

                            Button(
                                onClick = { toggleReadMessages() },
//                                enabled = connectionState,
                                colors = ButtonDefaults.buttonColors(
                                    containerColor = if (isReading)
                                        MaterialTheme.colorScheme.error
                                    else MaterialTheme.colorScheme.secondary
                                ),
                                modifier = Modifier.weight(1f),
                            ) {
                                Text(if (isReading) "Stop Reading" else "Start Reading")
                            }
                        }
                    }
                }

                // Message Log Section
                Card(
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(300.dp),
                    elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
                ) {
                    Column(
                        modifier = Modifier.padding(16.dp)
                    ) {
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.SpaceBetween,
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Text(
                                "Message Log",
                                style = MaterialTheme.typography.titleMedium
                            )
                            Row(
                                verticalAlignment = Alignment.CenterVertically
                            ) {
                                Switch(
                                    checked = autoScroll,
                                    onCheckedChange = { autoScroll = it }
                                )
                                Text(
                                    "Auto-scroll",
                                    modifier = Modifier.padding(start = 4.dp),
                                    style = MaterialTheme.typography.bodySmall
                                )
                            }
                        }

                        Spacer(modifier = Modifier.height(8.dp))

                        val listState = rememberLazyListState()

                        LaunchedEffect(messageLog.size) {
                            if (autoScroll && messageLog.isNotEmpty()) {
                                listState.animateScrollToItem(messageLog.size - 1)
                            }
                        }

                        LazyColumn(
                            state = listState,
                            modifier = Modifier
                                .fillMaxWidth()
                                .weight(1f)
                                .border(
                                    1.dp,
                                    Color.White,
                                    MaterialTheme.shapes.small
                                )
                                .padding(8.dp)
                        ) {
                            items(messageLog) { message ->
                                MessageLogItem(message)
                            }
                        }
                    }
                }

                // Bottom Actions
                Row(

                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween
                ) {
                    OutlinedButton(
                        onClick = {
                            scope.launch {
                                messageLog.clear()
                            }
                        }
                    ) {
                        Text("Clear Log")
                    }

                    Button(
                        onClick = {
                            isReading = false
                            showTableScreen = true
//                    sendAcknowledgePacket()
                        },

                        colors = ButtonDefaults.buttonColors(
                            containerColor = MaterialTheme.colorScheme.primary,
                        ),
                        enabled = !showTableScreen && connectionState

                    ) {
                        Text(if(showTableScreen) "Close Table" else "Show Table")
                    }

                    Button(
                        onClick = {
                            scope.launch(Dispatchers.IO) {
                                try {
                                    bluetoothSocket?.close()
                                    connectionState = !connectionState
                                    messageLog.add("Disconnected from ${device.address}")

//                                    delay(3000)
                                } catch (e: IOException) {
                                    messageLog.add("Disconnection failed: ${e.message}")
                                }
                                onClose()
                            }
                        },
                        colors = ButtonDefaults.buttonColors(
                            containerColor = MaterialTheme.colorScheme.error
                        )
                    ) {
                        Text("Disconnect")
                    }
                }
            }
        }


        if(showTableScreen && activity != null){
            Card(
                modifier = Modifier.fillMaxWidth(),
                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
            ) {
                TableScreen(device = device, bluetoothSocket = bluetoothSocket, onBack = { showTableScreen = false }, activity = activity)
            }
        }

    }
}


@SuppressLint("MissingPermission")
@Composable
fun ConnectJDY23DeviceScreen(device: BluetoothDevice, onClose: () -> Unit) {

    BackHandler {
        // Do nothing when the back button is pressed
    }

    val scope = rememberCoroutineScope()

    // State to track whether to show the table screen
    var showTableScreen by remember { mutableStateOf(false) }

    val context = LocalContext.current

    // Keeps track of the connection state
    var connectionState by remember { mutableStateOf(false) }

    // Keeps track of the messages sent and received
    val messageLog = remember { mutableStateListOf<String>() }

    val bluetoothManager: BluetoothManager by lazy {
        context.getSystemService(Context.BLUETOOTH_SERVICE) as BluetoothManager
    }

    // Bluetooth socket for communication
    var bluetoothSocket: BluetoothSocket? by remember { mutableStateOf(null) }

    var bluetoothGatt: BluetoothGatt? by remember { mutableStateOf(null) }

    var isCheckingConnection by remember { mutableStateOf(false) }

    var autoScroll by remember { mutableStateOf(true) }

    val classicBluetoothManager = remember { ClassicBluetoothManager() }

    var isReading by remember { mutableStateOf(false) }
    var currentMessage by remember { mutableStateOf("") }

    // New state variables for hex input
    var hexInput by remember { mutableStateOf("") }
    var isHexMode by remember { mutableStateOf(false) }

    // Validation function for hex input
    fun isValidHex(input: String): Boolean {
        return input.matches(Regex("^[0-9A-Fa-f\\s]*$"))
    }

    // Theme colors for status
    val connectionColor = if (connectionState) MaterialTheme.colorScheme.primary
    else MaterialTheme.colorScheme.error

    fun checkConnection(): Boolean {
        return bluetoothGatt?.let { gatt ->
            val connectionGATTState = bluetoothManager.getConnectionState(gatt.device, BluetoothProfile.GATT)
            if (connectionGATTState == BluetoothProfile.STATE_CONNECTED) {
                // Optionally, try reading a characteristic as a ping check
                val service = gatt.getService(UUID.fromString("0000FFE0-0000-1000-8000-00805F9B34FB"))
                val characteristic = service?.getCharacteristic(UUID.fromString("0000FFE1-0000-1000-8000-00805F9B34FB"))

                if (characteristic != null) {
                    gatt.readCharacteristic(characteristic)
                }

                true
            } else {
                Toast.makeText(context, "JDY-23 Disconnected, Reconnect Required", Toast.LENGTH_LONG).show()
                false
            }
        } ?: false
    }


    fun connectToDevice() {
        scope.launch(Dispatchers.Main) {
            if (classicBluetoothManager.isBluetoothAvailableAndEnabled()) {
                try {
                    isCheckingConnection = true
                    messageLog.add("Attempting to connect to ${device.address}...")

                    bluetoothGatt = device.connectGatt(context, false, object : BluetoothGattCallback() {
                        override fun onConnectionStateChange(gatt: BluetoothGatt, status: Int, newState: Int) {
                            when (newState) {
                                BluetoothProfile.STATE_CONNECTED -> {
                                    messageLog.add("Connected to JDY-23 BLE module")
                                    bluetoothGatt = gatt
                                    connectionState = true
                                    showTableScreen = true
                                    gatt.discoverServices() // Discover services
                                }
                                BluetoothProfile.STATE_DISCONNECTED -> {
                                    messageLog.add("Disconnected from JDY-23 BLE module")
                                    bluetoothGatt?.close()
                                    bluetoothGatt = null
                                    connectionState = false
                                }
                            }
                        }

                        override fun onServicesDiscovered(gatt: BluetoothGatt, status: Int) {
                            if (status == BluetoothGatt.GATT_SUCCESS) {
                                messageLog.add("Services discovered on JDY-23")
                                val service = gatt.getService(UUID.fromString("0000FFE0-0000-1000-8000-00805F9B34FB"))
                                val characteristic = service?.getCharacteristic(UUID.fromString("0000FFE0-0000-1000-8000-00805F9B34FB"))

                                if (characteristic != null) {
                                    messageLog.add("Found JDY-23 characteristic, sending dummy data to prevent disconnect")
                                    characteristic.value = byteArrayOf(0x01) // Send a dummy byte
                                    gatt.writeCharacteristic(characteristic)
                                }
                            }
                        }

                        @Deprecated("Deprecated in Java")
                        override fun onCharacteristicChanged(gatt: BluetoothGatt, characteristic: BluetoothGattCharacteristic) {
                            val receivedBytes = characteristic.value
                            val receivedMessage = receivedBytes.toString(Charsets.UTF_8)
                            val hexValue = receivedBytes.joinToString(" ") { "%02X".format(it) }

                            scope.launch(Dispatchers.Main) {
                                messageLog.add("Received: $receivedMessage")
                                messageLog.add("Hex: $hexValue")
                            }
                        }


                        override fun onCharacteristicWrite(
                            gatt: BluetoothGatt,
                            characteristic: BluetoothGattCharacteristic,
                            status: Int
                        ) {
                            if (status == BluetoothGatt.GATT_SUCCESS) {
                                messageLog.add("Write successful: Prevented auto-disconnect")
                            }
                        }
                    })

                } catch (e: Exception) {
                    messageLog.add("Connection failed: ${e.message}")
                    bluetoothGatt?.close()
                    bluetoothGatt = null
                    connectionState = false
                } finally {
                    isCheckingConnection = false
                }
            }
        }
    }



    fun disconnectDevice() {
        scope.launch(Dispatchers.IO) {
            try {
                bluetoothGatt?.disconnect()  // Request disconnection
                delay(500)  // Short delay to ensure proper disconnection
                bluetoothGatt?.close()  // Close GATT connection
                bluetoothGatt = null  // Avoid memory leaks

                connectionState = false
                messageLog.add("Disconnected from JDY-23")
            } catch (e: Exception) {
                messageLog.add("Disconnection failed: ${e.message}")
            }
        }
    }


    fun sendMessage() {
        scope.launch(Dispatchers.IO) {
            try {
                if (hexInput.isNotEmpty() && isValidHex(hexInput)) {
                    val hexBytes = hexToByteArray(hexInput)

                    val service = bluetoothGatt?.getService(UUID.fromString("0000FFE0-0000-1000-8000-00805F9B34FB"))
                    val characteristic = service?.getCharacteristic(UUID.fromString("0000FFE1-0000-1000-8000-00805F9B34FB"))

                    if (characteristic != null) {
                        characteristic.value = hexBytes
                        characteristic.writeType = BluetoothGattCharacteristic.WRITE_TYPE_DEFAULT // or WRITE_TYPE_NO_RESPONSE

                        val success = bluetoothGatt?.writeCharacteristic(characteristic) ?: false
                        if (success) {
                            messageLog.add("Sent HEX: $hexInput")
                        } else {
                            messageLog.add("Failed to send HEX data")
                        }
                    } else {
                        messageLog.add("BLE characteristic not found")
                    }

                    hexInput = ""
                }
                else {
                    if (currentMessage.isNotEmpty()) {
                        try {
//                            val decimalValue = currentMessage.toInt() // Convert string to integer
                            val messageBytes = currentMessage.toByteArray(Charsets.UTF_8) // Convert integer to byte array

                            // Get the writable characteristic (JDY-23 uses UUID FFE1 for TX)
                            val service = bluetoothGatt?.getService(UUID.fromString("0000FFE0-0000-1000-8000-00805F9B34FB"))
                            val characteristic = service?.getCharacteristic(UUID.fromString("0000FFE1-0000-1000-8000-00805F9B34FB"))

                            if (characteristic != null) {
                                characteristic.value = messageBytes
                                bluetoothGatt?.writeCharacteristic(characteristic)  // Write to BLE characteristic
                                messageLog.add("Sent TEXT: $currentMessage")
                                currentMessage = "" // Clear after sending
                            } else {
                                messageLog.add("Error: Characteristic not found")
                            }
                        } catch (e: Exception) {
                            messageLog.add("Error: Invalid Input, ${e.message}")
                        }
                    }
                }

            } catch (e: IOException) {
                messageLog.add("Send failed: ${e.message}")
            }
        }
    }

    fun toggleReadMessages() {
        scope.launch(Dispatchers.Main) {
            if (bluetoothGatt == null) {
                messageLog.add("BluetoothGatt not connected")
                return@launch
            }

            val service = bluetoothGatt?.getService(UUID.fromString("0000FFE0-0000-1000-8000-00805F9B34FB"))
            val characteristic = service?.getCharacteristic(UUID.fromString("0000FFE1-0000-1000-8000-00805F9B34FB"))

            if (characteristic == null) {
                messageLog.add("Failed to get JDY-23 characteristic")
                return@launch
            }

            // Toggle reading state
            isReading = !isReading

            if (isReading) {
                bluetoothGatt?.setCharacteristicNotification(characteristic, true)

                val descriptor = characteristic.getDescriptor(UUID.fromString("00002902-0000-1000-8000-00805F9B34FB"))
                descriptor?.value = BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE
                bluetoothGatt?.writeDescriptor(descriptor)

                messageLog.add("Reading enabled for JDY-23")
            } else {
                bluetoothGatt?.setCharacteristicNotification(characteristic, false)
                messageLog.add("Reading disabled for JDY-23")
            }
            if(!connectionState){
                isReading = !isReading
            }
        }
    }



    Column(
        modifier = Modifier
            .fillMaxSize()
            .verticalScroll(rememberScrollState()),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        Box(modifier = Modifier.fillMaxSize()) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .fillMaxSize()  // Take full size of parent
//                    .verticalScroll(rememberScrollState())  // Make column scrollable
                    .padding(16.dp),
                horizontalAlignment = Alignment.CenterHorizontally,
                verticalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                // Enhanced Header Section
                Card(
                    modifier = Modifier
                        .fillMaxWidth(),
                    elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
                ) {
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(6.dp),
                        horizontalArrangement = Arrangement.SpaceEvenly,  // Centers all content in the Box
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Column(
                            modifier = Modifier.padding(8.dp),
                            horizontalAlignment = Alignment.CenterHorizontally,
                        ) {
                            Text(
                                text = device.name ?: "Unknown Device",
                                style = MaterialTheme.typography.headlineMedium,
                                textAlign = TextAlign.Center
                            )
                            Text(
                                text = device.address,
                                style = MaterialTheme.typography.bodyMedium,
                                color = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                            Spacer(modifier = Modifier.height(8.dp))
                            Row(
                                verticalAlignment = Alignment.CenterVertically,
                                horizontalArrangement = Arrangement.Center
                            ) {
                                Box(
                                    modifier = Modifier
                                        .size(12.dp)
                                        .background(connectionColor, CircleShape)
                                )
                                Text(
                                    text = if (connectionState) "Connected" else "Disconnected",
                                    modifier = Modifier.padding(start = 8.dp),
                                    color = connectionColor,
                                    style = MaterialTheme.typography.bodyMedium
                                )
                            }
                        }
                    }
                }

                // Background connection checker
                LaunchedEffect(connectionState) {
                    scope.launch(Dispatchers.IO){
                        while (true) {
                            if (connectionState) {
                                val isStillConnected = checkConnection()
                                if (!isStillConnected && connectionState) {
                                    // Connection was lost
                                    connectionState = false
                                    messageLog.add("Connection lost. Device disconnected.")
                                    try {
                                        bluetoothSocket?.close()
                                    } catch (e: IOException) {
                                        // Ignore close errors
                                    }
                                    bluetoothSocket = null
                                }
                            }
                            delay(3000) // Check every second
                        }
                    }
                }

                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.Absolute.SpaceEvenly,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    // Connection Button
                    Button(
                        onClick = { if (connectionState) disconnectDevice() else connectToDevice() },
                        modifier = Modifier
                            .padding(10.dp)
                            .width(150.dp),
                        colors = ButtonDefaults.buttonColors(
                            containerColor = if (!connectionState) MaterialTheme.colorScheme.primary
                            else MaterialTheme.colorScheme.error
                        )
                    ) {
                        if (isCheckingConnection) {
                            CircularProgressIndicator(
                                modifier = Modifier.size(24.dp),
                                color = MaterialTheme.colorScheme.onPrimary
                            )
                        } else {
                            Text(text = if (connectionState) "Linked" else "Link")
                        }
                    }

                }


                // Message Input Card with Hex Support
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
                ) {
                    Column(
                        modifier = Modifier.padding(6.dp),
                        verticalArrangement = Arrangement.spacedBy(4.dp)
                    ) {

                        // Mode Switch
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.SpaceBetween,
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Text("Input Mode:")
                            Switch(
                                checked = isHexMode,
                                onCheckedChange = {
                                    isHexMode = it
                                    // Clear inputs when switching modes
                                    currentMessage = ""
                                    hexInput = ""
                                }
                            )
                            Text(if (isHexMode) "HEX" else "TEXT")
                        }

                        if (isHexMode) {
                            // Hex Input Field
                            OutlinedTextField(
                                value = hexInput,
                                onValueChange = { input ->
                                    if (isValidHex(input)) {
                                        hexInput = input.uppercase()
                                    }
                                },
                                label = { Text("Hex Value (e.g., AB BB 00)") },
                                modifier = Modifier.fillMaxWidth(),
                                colors = OutlinedTextFieldDefaults.colors(
                                    focusedBorderColor = MaterialTheme.colorScheme.primary,
                                    unfocusedBorderColor = MaterialTheme.colorScheme.outline
                                ),
                                isError = hexInput.isNotEmpty() && !isValidHex(hexInput)
                            )
                            // Helper text for hex input
                            Text(
                                "Enter hex values separated by spaces",
                                style = MaterialTheme.typography.bodySmall,
                                color = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                        } else {
                            // Regular text input
                            OutlinedTextField(
                                value = currentMessage,
                                onValueChange = { currentMessage = it },
                                label = { Text("Text Message") },
                                modifier = Modifier.fillMaxWidth()
                            )
                        }

                        Column(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalAlignment = Alignment.CenterHorizontally,
                            verticalArrangement = Arrangement.Center
                        ) {
                            // Quick Hex Buttons
                            if (isHexMode) {
                                val quickHexValues = listOf(
                                    "AB BB 31 00 00",
                                    "AB BB 32 00 00",
                                    "AB BB 33 00 00",
                                    "AB BB 34 00 00",
                                    "AB BB 35 00 00",
                                    "AB BB 36 00 00",
                                    "AB BB 37 00 00",
                                    "AB BB 38 00 00",
                                    "AB BB 39 00 00",
                                    "AB BB 3A 00 00",
                                    "AB BB 3B 00 00",
                                    "AB BB 3C 00 00",
                                ) // Static hex values

                                quickHexValues.chunked(2).forEach { rowHexValues ->
                                    Row(
                                        modifier = Modifier.fillMaxWidth(),
                                        horizontalArrangement = Arrangement.SpaceEvenly
                                    ) {
                                        rowHexValues.forEach { hex ->
                                            OutlinedButton(
                                                onClick = {
                                                    // Add the clicked hex to hexInput
                                                    hexInput = if (hexInput.isEmpty()) hex else "$hexInput $hex"
                                                },
                                                modifier = Modifier.weight(1f)
                                            ) {
                                                Text(hex)
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        // Send Button Row
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.spacedBy(4.dp)
                        ) {
                            Button(
                                onClick = { sendMessage() },
//                                enabled = connectionState && hexInput.isNotEmpty() && isValidHex(hexInput),
                                enabled = connectionState,
                                modifier = Modifier.weight(1f),
                            ) {
                                Text("Send HEX")
                            }

                            Button(
                                onClick = { toggleReadMessages() },
                                enabled = connectionState,
                                colors = ButtonDefaults.buttonColors(
                                    containerColor = if (isReading)
                                        MaterialTheme.colorScheme.error
                                    else MaterialTheme.colorScheme.secondary
                                ),
                                modifier = Modifier.weight(1f),
                            ) {
                                Text(if (isReading) "Stop Reading" else "Start Reading")
                            }
                        }
                    }
                }

                // Message Log Section
                Card(
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(300.dp),
                    elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
                ) {
                    Column(
                        modifier = Modifier.padding(16.dp)
                    ) {
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.SpaceBetween,
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Text(
                                "Message Log",
                                style = MaterialTheme.typography.titleMedium
                            )
                            Row(
                                verticalAlignment = Alignment.CenterVertically
                            ) {
                                Switch(
                                    checked = autoScroll,
                                    onCheckedChange = { autoScroll = it }
                                )
                                Text(
                                    "Auto-scroll",
                                    modifier = Modifier.padding(start = 4.dp),
                                    style = MaterialTheme.typography.bodySmall
                                )
                            }
                        }

                        Spacer(modifier = Modifier.height(8.dp))

                        val listState = rememberLazyListState()

                        LaunchedEffect(messageLog.size) {
                            if (autoScroll && messageLog.isNotEmpty()) {
                                listState.animateScrollToItem(messageLog.size - 1)
                            }
                        }

                        LazyColumn(
                            state = listState,
                            modifier = Modifier
                                .fillMaxWidth()
                                .weight(1f)
                                .border(
                                    1.dp,
                                    Color.White,
                                    MaterialTheme.shapes.small
                                )
                                .padding(8.dp)
                        ) {
                            items(messageLog) { message ->
                                MessageLogItem(message)
                            }
                        }
                    }
                }

                // Bottom Actions
                Row(

                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween
                ) {
                    OutlinedButton(
                        onClick = {
                            scope.launch {
                                messageLog.clear()
                            }
                        }
                    ) {
                        Text("Clear Log")
                    }

//                    Button(
//                        onClick = {
//                            isReading = false
//                            showTableScreen = true
////                    sendAcknowledgePacket()
//                        },
//
//                        colors = ButtonDefaults.buttonColors(
//                            containerColor = MaterialTheme.colorScheme.primary,
//                        ),
//                        enabled = !showTableScreen && connectionState
//
//                    ) {
//                        Text(if(showTableScreen) "Close Table" else "Show Table")
//                    }

                    Button(
                        onClick = {
                            scope.launch(Dispatchers.IO) {
                                try {
                                    bluetoothGatt?.disconnect()  // First, request a proper disconnection
                                    delay(500)  // Give some time for the BLE stack to process the disconnect
                                    bluetoothGatt?.close()  // Now, release the connection resources
                                    bluetoothGatt = null  // Prevent memory leaks

                                    connectionState = false  // Explicitly set to false
                                    messageLog.add("Disconnected from JDY-23")
                                } catch (e: Exception) {  // Catch general exceptions
                                    messageLog.add("Disconnection failed: ${e.message}")
                                }
                                onClose()  // Execute any cleanup logic after disconnecting
                            }

                        },
                        colors = ButtonDefaults.buttonColors(
                            containerColor = MaterialTheme.colorScheme.error
                        )
                    ) {
                        Text("Disconnect")
                    }
                }
            }
        }


//        if(showTableScreen && activity != null){
//            Card(
//                modifier = Modifier.fillMaxWidth(),
//                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
//            ) {
//                TableScreen(device = device, bluetoothSocket = bluetoothSocket, onBack = { showTableScreen = false }, activity = activity)
//            }
//        }

    }
}


@Composable
private fun MessageLogItem(message: String) {
    val isReceived = message.startsWith("Received:")
    val isSent = message.startsWith("Sent:")
    val isHex = message.startsWith("Hex:")

    val backgroundColor = when {
        isReceived -> MaterialTheme.colorScheme.primaryContainer.copy(alpha = 0.1f)
        isSent -> MaterialTheme.colorScheme.secondaryContainer.copy(alpha = 0.1f)
        isHex -> MaterialTheme.colorScheme.primaryContainer.copy(alpha = 0.1f)
        else -> Color.Transparent
    }

    Surface(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 4.dp),
        color = backgroundColor,
        shape = MaterialTheme.shapes.small
    ) {
        Text(
            text = message,
            modifier = Modifier.padding(8.dp),
            style = MaterialTheme.typography.bodySmall,
            color = when {
                isReceived -> MaterialTheme.colorScheme.primary
                isSent -> MaterialTheme.colorScheme.secondary
                isHex -> MaterialTheme.colorScheme.primary
                else -> MaterialTheme.colorScheme.onSurface
            }
        )
    }
}



@Composable
private fun PasswordChangeContent(
    digitInput: String,
    onDigitInputChange: (String) -> Unit,
    connectionState: Boolean,
    onChangePassword: () -> Unit
) {
    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 16.dp),
        verticalArrangement = Arrangement.spacedBy(24.dp)
    ) {
        // Description
        Text(
            "Change your device's 4-digit password",
            style = MaterialTheme.typography.bodyLarge,
            color = MaterialTheme.colorScheme.onSurfaceVariant,
            textAlign = TextAlign.Center,
            modifier = Modifier.padding(vertical = 16.dp)
        )

        // Password Input Card
        Card(
            modifier = Modifier
                .fillMaxWidth()
                .animateContentSize(),
            elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),
            shape = RoundedCornerShape(16.dp)
        ) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(24.dp),
                verticalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                OutlinedTextField(
                    value = digitInput,
                    onValueChange = onDigitInputChange,
                    label = { Text("New Password") },
                    supportingText = { Text("${digitInput.length}/4 digits entered") },
                    keyboardOptions = KeyboardOptions(
                        keyboardType = KeyboardType.NumberPassword,
                        imeAction = ImeAction.Done
                    ),
                    visualTransformation = PasswordVisualTransformation(),
                    singleLine = true,
                    modifier = Modifier.fillMaxWidth(),
                    shape = RoundedCornerShape(12.dp)
                )

                // Password Requirements
                Row(
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    Icon(
                        imageVector = if (digitInput.length == 4) Icons.Rounded.CheckCircle else Icons.Rounded.Info,
                        contentDescription = null,
                        tint = if (digitInput.length == 4) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.outline,
                        modifier = Modifier.size(16.dp)
                    )
                    Text(
                        "Must be exactly 4 digits",
                        style = MaterialTheme.typography.bodySmall,
                        color = if (digitInput.length == 4) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.outline
                    )
                }
            }
        }

        Button(
            onClick = onChangePassword,
            enabled = connectionState && digitInput.length == 4,
            modifier = Modifier
                .fillMaxWidth()
                .height(50.dp),
            shape = RoundedCornerShape(12.dp)
        ) {
            if (connectionState && digitInput.length == 4) {
                Icon(
                    Icons.Rounded.Lock,
                    contentDescription = null,
                    modifier = Modifier.padding(end = 8.dp)
                )
            }
            Text("Change Password")
        }
    }
}

@Composable
private fun DeviceNameContent(
    deviceName: String,
    onDeviceNameChange: (String) -> Unit,
    connectionState: Boolean,
    onUpdateDeviceName: () -> Unit
) {
    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 16.dp),
        verticalArrangement = Arrangement.spacedBy(24.dp)
    ) {
        // Description
        Text(
            "Change your device's name",
            style = MaterialTheme.typography.bodyLarge,
            color = MaterialTheme.colorScheme.onSurfaceVariant,
            textAlign = TextAlign.Center,
            modifier = Modifier.padding(vertical = 16.dp)
        )

        // Device Name Input Card
        Card(
            modifier = Modifier
                .fillMaxWidth()
                .animateContentSize(),
            elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),
            shape = RoundedCornerShape(16.dp)
        ) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(24.dp),
                verticalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                OutlinedTextField(
                    value = deviceName,
                    onValueChange = onDeviceNameChange,
                    label = { Text("Device Name") },
                    supportingText = { Text("Enter a unique name for your device") },
                    keyboardOptions = KeyboardOptions(
                        keyboardType = KeyboardType.Text,
                        imeAction = ImeAction.Done
                    ),
                    singleLine = true,
                    modifier = Modifier.fillMaxWidth(),
                    shape = RoundedCornerShape(12.dp)
                )

                // Name Requirements
                Row(
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    Icon(
                        imageVector = if (deviceName.isNotBlank()) Icons.Rounded.CheckCircle else Icons.Rounded.Info,
                        contentDescription = null,
                        tint = if (deviceName.isNotBlank()) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.outline,
                        modifier = Modifier.size(16.dp)
                    )
                    Text(
                        "Device name cannot be empty",
                        style = MaterialTheme.typography.bodySmall,
                        color = if (deviceName.isNotBlank()) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.outline
                    )
                }
            }
        }

        Button(
            onClick = onUpdateDeviceName,
            enabled = connectionState && deviceName.isNotBlank(),
            modifier = Modifier
                .fillMaxWidth()
                .height(50.dp),
            shape = RoundedCornerShape(12.dp)
        ) {
            if (connectionState && deviceName.isNotBlank()) {
                Icon(
                    Icons.Rounded.Edit,
                    contentDescription = null,
                    modifier = Modifier.padding(end = 8.dp)
                )
            }
            Text("Update Device Name")
        }
    }
}

***************************************** ConnectHC-05 function ************************************

//@SuppressLint("MissingPermission")
//@Composable
//fun ConnectHC05DeviceScreen(device: BluetoothDevice, onClose: () -> Unit) {
//
//    BackHandler {
//        // Do nothing when the back button is pressed
//    }
//
//    val scope = rememberCoroutineScope()
//
//    // State to track whether to show the table screen
//    var showTableScreen by remember { mutableStateOf(false) }
//
//    // Get the Activity context from LocalContext
//    val activity = LocalContext.current as? Activity
//
//    val context = LocalContext.current
//
//    // Keeps track of the connection state
//    var connectionState by remember { mutableStateOf(false) }
//
//    // Keeps track of the messages sent and received
//    val messageLog = remember { mutableStateListOf<String>() }
//
//    // Bluetooth socket for communication
//    var bluetoothSocket: BluetoothSocket? by remember { mutableStateOf(null) }
//
//    var isCheckingConnection by remember { mutableStateOf(false) }
//
//    var autoScroll by remember { mutableStateOf(true) }
//
//    val classicBluetoothManager = remember { ClassicBluetoothManager() }
//
//    var isReading by remember { mutableStateOf(false) }
//    var currentMessage by remember { mutableStateOf("") }
//    // New state variables for hex input
//    var hexInput by remember { mutableStateOf("") }
//    var isHexMode by remember { mutableStateOf(false) }
//    // Validation function for hex input
//    fun isValidHex(input: String): Boolean {
//        return input.matches(Regex("^[0-9A-Fa-f\\s]*$"))
//    }
//
//    // Theme colors for status
//    val connectionColor = if (connectionState) MaterialTheme.colorScheme.primary
//    else MaterialTheme.colorScheme.error
//
//
//    var count = 0
//    fun checkConnection(): Boolean {
//        return try {
//
//            bluetoothSocket?.let { socket ->
//                if (socket.isConnected) {
//                    count += 1
//                    // Send a small ping to verify the connection
//                    if(count == 3)
//                    {
//                        socket.outputStream?.write(0) // Attempt to write a single byte
//                        count = 0
//                    }
//                    true
//                } else {
//                    false
//                }
//            } == true
//        } catch (e: IOException) {
//            Toast.makeText(context, "Connection Lost, Connect Again", Toast.LENGTH_LONG).show()
//            false
//        }
//    }
////
////    fun crc_16bit_modbus(buffer: ByteArray): Int {
////        var crc = 0xFFFF
////
////        for (byte in buffer) {
////            crc = crc xor (byte.hashCode() and 0xFF)
////
////            repeat(8) {
////                crc = if (crc and 1 != 0) {
////                    (crc ushr 1) xor 0xA001
////                } else {
////                    crc ushr 1
////                }
////            }
////        }
////
////        return crc and 0xFFFF
////    }
//
////    fun changePassword() {
////        val buffer = ByteArray(1024)
////        scope.launch(Dispatchers.IO) {
////            try {
////                if (digitInput.length == 4 && isValidDigits(digitInput)) {
////
////                    val digitByte = digitInput.map {
////                        it.code.toByte()
////                    }
////
//////                    ********** 3rd Way (Whole No. as Ascii Value) **********
//////                    // Convert the entire input string to ASCII bytes
//////                    val digitBytes = digitInput.map {
//////                        it.code.toByte()  // This converts each character to its ASCII value
//////                    }.toByteArray()
////
////
////
////                    // Calculate checksum
//////                    val checksum = crc_16bit_modbus(digitBytes)
////
////                    // Convert to formatted hex string (12 83 AF 7A format)
////                    val hexString = StringBuilder()
////
////                    // Add header
////                    hexString.append("AB BA 31 ")
////
////                    // Convert the entire input to hex and split into pairs
////                    val number = digitInput.toInt()
////                    hexString.append(String.format("%02X %02X ",
////                        (number shr 8) and 0xFF,  // Gets "04"
////                        number and 0xFF           // Gets "D2"
////                    ))
////
////                    val digitBytes = hexString.map {
////                        it.code.toByte()  // This converts each character to its ASCII value
////                    }.toByteArray()
////
////                    val checksum = crc_16bit_modbus(digitBytes)
////
////                    messageLog.add("number: $number")
////                    messageLog.add("CheckSum: $checksum")
////
////
////                    // Add checksum as two separate bytes
//////                    hexString.append(String.format("%02X ", (checksum ushr 8).toByte()))  // High byte
//////                    hexString.append(String.format("%02X", checksum.toByte()))            // Low byte
////
////                    val finalHexString = hexString.toString()
////
////                    messageLog.add("Sending: ${(finalHexString)}")
////
////                    // Convert to byte array and send
////                    bluetoothSocket?.outputStream?.write(hexToByteArray(finalHexString))
////                    messageLog.add("Password Changed. Sent HEX: $finalHexString")
////
////                    // Clear input
////                    digitInput = ""
////                    delay(2000)
////                    disconnectAndUnpair()
////                    onClose()
////                }
////            } catch (e: IOException) {
////                messageLog.add("Password change failed: ${e.message}")
////            }
////        }
////    }
//
//    fun connectToDevice() {
//        scope.launch(Dispatchers.IO) {
//            if (classicBluetoothManager.isBluetoothAvailableAndEnabled()) {
//                try {
//                    isCheckingConnection = true
//                    messageLog.add("Attempting to connect to ${device.address}...")
//                    val socket = device.createRfcommSocketToServiceRecord(
//                        UUID.fromString("00001101-0000-1000-8000-00805F9B34FB")
//
//                    )
//                    withTimeout(10000) { socket.connect() }
//                    bluetoothSocket = socket
//                    connectionState = true
//                    showTableScreen = true
//                    messageLog.add("Successfully connected to ${device.address}")
//                } catch (e: IOException) {
//                    withContext(Dispatchers.Main) {
//                        messageLog.add("Connection failed: ${e.message}")
//                        bluetoothSocket?.close()
//                        bluetoothSocket = null
//                        connectionState = false
//                    }
//                } finally {
//                    isCheckingConnection = false
//                }
//            }
//        }
//    }
//
//
//
//    fun disconnectDevice() {
//        scope.launch(Dispatchers.IO) {
//            try {
//                bluetoothSocket?.close()
//                connectionState = false
//                messageLog.add("Disconnected from ${device.address}")
//            } catch (e: IOException) {
//                messageLog.add("Disconnection failed: ${e.message}")
//            }
//        }
//    }
////
////    fun sendAcknowledgePacket() {
////        if(checkConnection()){
////            scope.launch(Dispatchers.IO) {
////                try {
////                    val buffer = ByteArray(1024)
////                    val ackPacket = hexToByteArray("AB BB 39 00 00")
////                    bluetoothSocket?.outputStream?.write(ackPacket)
////
////                    val receivedData = mutableListOf<Byte>()
////                    val timeoutMillis = 5000L // Timeout in milliseconds
////                    val startTime = System.currentTimeMillis()
////
////                    while (System.currentTimeMillis() - startTime < timeoutMillis) {
////                        val bytesAvailable = bluetoothSocket?.inputStream?.available() ?: 0
////                        if (bytesAvailable > 0) {
////                            val bytesRead = bluetoothSocket?.inputStream?.read(buffer) ?: 0
////                            if (bytesRead > 0) {
////                                receivedData.addAll(buffer.take(bytesRead))
////                                val receivedHex = receivedData.joinToString(" ") { "%02X".format(it) }
////
////                                // Check if the received data matches the expected packet
////                                if (receivedHex.contains("AB BB 39 00 00")) {
////                                    showTableScreen = true
////                                    return@launch
////                                }
////                            }
////                        }
////                        delay(100) // Prevent busy-waiting
////                    }
////                }catch (e: IOException) {
////                    Toast.makeText(
////                        context,
////                        "Error during acknowledgment: ${e.message}",
////                        Toast.LENGTH_LONG
////                    ).show()
////                }
////            }
////        }else{
////            Toast.makeText(context, "Connection Lost, Connect again", Toast.LENGTH_LONG).show()
////            connectionState = false
////        }
////    }
////
//
//    fun sendMessage() {
//        scope.launch(Dispatchers.IO) {
//            try {
//                if (hexInput.isNotEmpty() && isValidHex(hexInput)) {
//                    val hexBytes = hexToByteArray(hexInput)
//                    bluetoothSocket?.outputStream?.write(hexBytes)
//                    messageLog.add("Sent HEX: $hexInput")
//                    hexInput = ""
//                }
////                else {
////                    if (currentMessage.isNotEmpty()) {
////                        try {
////                            val decimalValue = currentMessage.toInt() // Convert string to integer
////                            val messageBytes = decimalValue.toString().toByteArray() // Convert integer to bytes
////                            bluetoothSocket?.outputStream?.write(messageBytes)
////                            messageLog.add("Sent DECIMAL: $decimalValue")
////                            currentMessage = "" // Clear after sending
////                        } catch (e: NumberFormatException) {
////                            messageLog.add("Error: Invalid number format")
////                        }
////                    }
////                }
//            } catch (e: IOException) {
//                messageLog.add("Send failed: ${e.message}")
//            }
//        }
//    }
//
//    fun toggleReadMessages() {
//        scope.launch(Dispatchers.IO) {
//            try {
//                isReading = !isReading
//                val buffer = ByteArray(1024)
//
//                while (isReading && bluetoothSocket?.isConnected == true) {
//                    val bytesAvailable = bluetoothSocket?.inputStream?.available() ?: 0
//
//                    if (bytesAvailable > 0) {
//                        val bytes = bluetoothSocket?.inputStream?.read(buffer) ?: 0
//                        if (bytes > 0) {
//                            val receivedMessage = String(buffer, 0, bytes)
//                            val hexValue = buffer.take(bytes).joinToString(" ") { "%02X".format(it) }
//                            withContext(Dispatchers.Main) {
//                                messageLog.add("Received: $receivedMessage")
//                                messageLog.add("Hex: $hexValue")
//                            }
//                        }
//                    }
//                    delay(100)
//                }
//            } catch (e: IOException) {
//                withContext(Dispatchers.Main) {
//                    messageLog.add("Receive failed: ${e.message}")
//                }
//            } finally {
//                isReading = false
//            }
//        }
//    }
//
//
//    Column(
//        modifier = Modifier
//            .fillMaxSize()
//            .verticalScroll(rememberScrollState()),
//        horizontalAlignment = Alignment.CenterHorizontally,
//        verticalArrangement = Arrangement.spacedBy(12.dp)
//    ) {
//        Box(modifier = Modifier.fillMaxSize()) {
//            Column(
//                modifier = Modifier
//                    .fillMaxWidth()
//                    .fillMaxSize()  // Take full size of parent
////                    .verticalScroll(rememberScrollState())  // Make column scrollable
//                    .padding(16.dp),
//                horizontalAlignment = Alignment.CenterHorizontally,
//                verticalArrangement = Arrangement.spacedBy(12.dp)
//            ) {
//                // Enhanced Header Section
//                Card(
//                    modifier = Modifier
//                        .fillMaxWidth(),
//                    elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
//                ) {
//                    Row(
//                        modifier = Modifier
//                            .fillMaxWidth()
//                            .padding(6.dp),
//                        horizontalArrangement = Arrangement.SpaceEvenly,  // Centers all content in the Box
//                        verticalAlignment = Alignment.CenterVertically
//                    ) {
//                        Column(
//                            modifier = Modifier.padding(8.dp),
//                            horizontalAlignment = Alignment.CenterHorizontally,
//                        ) {
//                            Text(
//                                text = device.name ?: "Unknown Device",
//                                style = MaterialTheme.typography.headlineMedium,
//                                textAlign = TextAlign.Center
//                            )
//                            Text(
//                                text = device.address,
//                                style = MaterialTheme.typography.bodyMedium,
//                                color = MaterialTheme.colorScheme.onSurfaceVariant
//                            )
//                            Spacer(modifier = Modifier.height(8.dp))
//                            Row(
//                                verticalAlignment = Alignment.CenterVertically,
//                                horizontalArrangement = Arrangement.Center
//                            ) {
//                                Box(
//                                    modifier = Modifier
//                                        .size(12.dp)
//                                        .background(connectionColor, CircleShape)
//                                )
//                                Text(
//                                    text = if (connectionState) "Connected" else "Disconnected",
//                                    modifier = Modifier.padding(start = 8.dp),
//                                    color = connectionColor,
//                                    style = MaterialTheme.typography.bodyMedium
//                                )
//                            }
//                        }
//                    }
//                }
//
//                // Background connection checker
//                LaunchedEffect(connectionState) {
//                    scope.launch(Dispatchers.IO){
//                        while (true) {
//                            if (connectionState) {
//                                val isStillConnected = checkConnection()
//                                if (!isStillConnected && connectionState) {
//                                    // Connection was lost
//                                    connectionState = false
//                                    messageLog.add("Connection lost. Device disconnected.")
//                                    try {
//                                        bluetoothSocket?.close()
//                                    } catch (e: IOException) {
//                                        // Ignore close errors
//                                    }
//                                    bluetoothSocket = null
//                                }
//                            }
//                            delay(3000) // Check every second
//                        }
//                    }
//                }
//
//                Row(
//                    modifier = Modifier.fillMaxWidth(),
//                    horizontalArrangement = Arrangement.Absolute.SpaceEvenly,
//                    verticalAlignment = Alignment.CenterVertically
//                ) {
//                    // Connection Button
//                    Button(
//                        onClick = { if (connectionState) disconnectDevice() else connectToDevice() },
//                        modifier = Modifier
//                            .padding(10.dp)
//                            .width(150.dp),
//                        colors = ButtonDefaults.buttonColors(
//                            containerColor = if (!connectionState) MaterialTheme.colorScheme.primary
//                            else MaterialTheme.colorScheme.error
//                        )
//                    ) {
//                        if (isCheckingConnection) {
//                            CircularProgressIndicator(
//                                modifier = Modifier.size(24.dp),
//                                color = MaterialTheme.colorScheme.onPrimary
//                            )
//                        } else {
//                            Text(text = if (connectionState) "Linked" else "Link")
//                        }
//                    }
//
//
////                    if(!settingCall){
////                        Button(
////                            onClick = { settingCall = true },
////                            modifier = Modifier
////                                .padding(10.dp)
////                                .width(150.dp),
////                            colors = ButtonDefaults.buttonColors(
////                                containerColor = MaterialTheme.colorScheme.primary
////                            ),
////                            enabled = connectionState
////
////                            ) {
////                            Row(
////                                modifier = Modifier.fillMaxWidth(),
////                                horizontalArrangement = Arrangement.Absolute.SpaceEvenly,
////                                verticalAlignment = Alignment.CenterVertically
////                            ) {
////                                Text(
////                                    text = "Settings",
////                                    color = Color.Unspecified,
////                                )
////                                Icon(Icons.Filled.Settings, contentDescription = "Settings")
////                            }
////                        }
////                    }
//                }
//
////                if(settingCall){
////
////                    BasicAlertDialog(
////                        onDismissRequest = { settingCall = false },
////                        modifier = Modifier
////                            .fillMaxSize()
////                            .fillMaxWidth(),
////                        properties = DialogProperties(
////                            usePlatformDefaultWidth = false // This removes the default width constraint
////                        )
////                    ) {
////                        var selectedTab by remember { mutableIntStateOf(0) }
////                        val tabs = listOf("Password", "Device Name")
////
////                        Scaffold(
////                            topBar = {
////                                TopAppBar(
////                                    title = {
////                                        Text("Settings")
////                                    },
////                                    actions = {
////                                        // Header with Back Button
////                                        Row(
////                                            modifier = Modifier
////                                                .fillMaxWidth()
////                                                .padding(16.dp),
////                                            horizontalArrangement = Arrangement.Start,
////                                            verticalAlignment = Alignment.CenterVertically
////                                        ) {
////                                            IconButton(onClick = { settingCall = false }) {
////                                                Icon(Icons.Rounded.ArrowBackIosNew, "Back")
////                                            }
////                                            Text(
////                                                "Device Settings",
////                                                style = MaterialTheme.typography.headlineMedium
////                                            )
////
////                                        }
////                                    }
////                                )
////                            },
////                            bottomBar = { BottomAppBar {
////                                NavigationBarItem(
////                                    selected = currentRoute == "settings",
////                                    onClick = {
////
////                                    },
////                                    icon = { Icon(Icons.Filled.Settings, contentDescription = "Settings") },
////                                    label = { Text("Settings") }
////                                )
////                            } },
////                        ) { innerPadding ->
////                            Box(
////                                modifier = Modifier
////                                    .fillMaxSize()
////                                    .background(MaterialTheme.colorScheme.background)
////                                    .padding(innerPadding)
////                            ) {
////                                Column(
////                                    modifier = Modifier
////                                        .fillMaxSize()
////                                        .padding(16.dp)
////                                ) {
////
////
////                                    // Tabs
////                                    TabRow(
////                                        selectedTabIndex = selectedTab,
////                                        modifier = Modifier.fillMaxWidth()
////                                    ) {
////                                        tabs.forEachIndexed { index, title ->
////                                            Tab(
////                                                selected = selectedTab == index,
////                                                onClick = { selectedTab = index },
////                                                text = { Text(title) },
////                                                icon = {
////                                                    Icon(
////                                                        imageVector = when (index) {
////                                                            0 -> Icons.Rounded.Lock
////                                                            else -> Icons.Rounded.Edit
////                                                        },
////                                                        contentDescription = null
////                                                    )
////                                                }
////                                            )
////                                        }
////                                    }
////
////                                    // Content
////                                    Box(
////                                        modifier = Modifier
////                                            .verticalScroll(rememberScrollState())
////                                            .padding(vertical = 16.dp),
////
////                                        ) {
////                                        when (selectedTab) {
////                                            0 -> PasswordChangeContent(
////                                                digitInput = digitInput,
////                                                onDigitInputChange = {
////                                                    val filteredInput = it.filter { char -> char.isDigit() }
////                                                    digitInput = filteredInput.take(4)
////                                                },
////                                                connectionState = connectionState,
////                                                onChangePassword = { changePassword() }
////                                            )
////                                            1 -> DeviceNameContent(
////                                                deviceName = deviceName,
////                                                onDeviceNameChange = { deviceName = it },
////                                                connectionState = connectionState,
////                                                onUpdateDeviceName = {  }
////                                            )
////                                        }
////                                        // Back button
////                                        Button(
////                                            onClick = { settingCall = false },
////                                            modifier = Modifier.padding(top = 400.dp),
////
////                                            ){
////                                            Text(text = "Back")
////                                        }
////                                    }
////                                }
////                            }
////                        }
////                    }
////                }
//
//                // Message Input Card with Hex Support
//                Card(
//                    modifier = Modifier.fillMaxWidth(),
//                    elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
//                ) {
//                    Column(
//                        modifier = Modifier.padding(6.dp),
//                        verticalArrangement = Arrangement.spacedBy(4.dp)
//                    ) {
//
//                        // Mode Switch
//                        Row(
//                            modifier = Modifier.fillMaxWidth(),
//                            horizontalArrangement = Arrangement.SpaceBetween,
//                            verticalAlignment = Alignment.CenterVertically
//                        ) {
//                            Text("Input Mode:")
//                            Switch(
//                                checked = isHexMode,
//                                onCheckedChange = {
//                                    isHexMode = it
//                                    // Clear inputs when switching modes
//                                    currentMessage = ""
//                                    hexInput = ""
//                                }
//                            )
//                            Text(if (isHexMode) "HEX" else "TEXT")
//                        }
//
//                        if (isHexMode) {
//                            // Hex Input Field
//                            OutlinedTextField(
//                                value = hexInput,
//                                onValueChange = { input ->
//                                    if (isValidHex(input)) {
//                                        hexInput = input.uppercase()
//                                    }
//                                },
//                                label = { Text("Hex Value (e.g., AB BB 00)") },
//                                modifier = Modifier.fillMaxWidth(),
//                                colors = OutlinedTextFieldDefaults.colors(
//                                    focusedBorderColor = MaterialTheme.colorScheme.primary,
//                                    unfocusedBorderColor = MaterialTheme.colorScheme.outline
//                                ),
//                                isError = hexInput.isNotEmpty() && !isValidHex(hexInput)
//                            )
//                            // Helper text for hex input
//                            Text(
//                                "Enter hex values separated by spaces",
//                                style = MaterialTheme.typography.bodySmall,
//                                color = MaterialTheme.colorScheme.onSurfaceVariant
//                            )
//                        } else {
//                            // Regular text input
//                            OutlinedTextField(
//                                value = currentMessage,
//                                onValueChange = { currentMessage = it },
//                                label = { Text("Text Message") },
//                                modifier = Modifier.fillMaxWidth()
//                            )
//                        }
//
//                        Column(
//                            modifier = Modifier.fillMaxWidth(),
//                            horizontalAlignment = Alignment.CenterHorizontally,
//                            verticalArrangement = Arrangement.Center
//                        ) {
//                            // Quick Hex Buttons
//                            if (isHexMode) {
//                                val quickHexValues = listOf(
//                                    "AB BB 31 00 00",
//                                    "AB BB 32 00 00",
//                                    "AB BB 33 00 00",
//                                    "AB BB 34 00 00",
//                                    "AB BB 35 00 00",
//                                    "AB BB 36 00 00",
//                                    "AB BB 37 00 00",
//                                    "AB BB 38 00 00",
//                                    "AB BB 39 00 00",
//                                    "AB BB 3A 00 00",
//                                    "AB BB 3B 00 00",
//                                    "AB BB 3C 00 00",
//                                ) // Static hex values
//
//                                quickHexValues.chunked(2).forEach { rowHexValues ->
//                                    Row(
//                                        modifier = Modifier.fillMaxWidth(),
//                                        horizontalArrangement = Arrangement.SpaceEvenly
//                                    ) {
//                                        rowHexValues.forEach { hex ->
//                                            OutlinedButton(
//                                                onClick = {
//                                                    // Add the clicked hex to hexInput
//                                                    hexInput = if (hexInput.isEmpty()) hex else "$hexInput $hex"
//                                                },
//                                                modifier = Modifier.weight(1f)
//                                            ) {
//                                                Text(hex)
//                                            }
//                                        }
//                                    }
//                                }
//                            }
//                        }
//
//                        // Send Button Row
//                        Row(
//                            modifier = Modifier.fillMaxWidth(),
//                            horizontalArrangement = Arrangement.spacedBy(4.dp)
//                        ) {
//                            Button(
//                                onClick = { sendMessage() },
////                                enabled = connectionState && hexInput.isNotEmpty() && isValidHex(hexInput),
////                                enabled = connectionState,
//                                modifier = Modifier.weight(1f),
//                            ) {
//                                Text("Send HEX")
//                            }
//
//                            Button(
//                                onClick = { toggleReadMessages() },
////                                enabled = connectionState,
//                                colors = ButtonDefaults.buttonColors(
//                                    containerColor = if (isReading)
//                                        MaterialTheme.colorScheme.error
//                                    else MaterialTheme.colorScheme.secondary
//                                ),
//                                modifier = Modifier.weight(1f),
//                            ) {
//                                Text(if (isReading) "Stop Reading" else "Start Reading")
//                            }
//                        }
//                    }
//                }
//
//                // Message Log Section
//                Card(
//                    modifier = Modifier
//                        .fillMaxWidth()
//                        .height(300.dp),
//                    elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
//                ) {
//                    Column(
//                        modifier = Modifier.padding(16.dp)
//                    ) {
//                        Row(
//                            modifier = Modifier.fillMaxWidth(),
//                            horizontalArrangement = Arrangement.SpaceBetween,
//                            verticalAlignment = Alignment.CenterVertically
//                        ) {
//                            Text(
//                                "Message Log",
//                                style = MaterialTheme.typography.titleMedium
//                            )
//                            Row(
//                                verticalAlignment = Alignment.CenterVertically
//                            ) {
//                                Switch(
//                                    checked = autoScroll,
//                                    onCheckedChange = { autoScroll = it }
//                                )
//                                Text(
//                                    "Auto-scroll",
//                                    modifier = Modifier.padding(start = 4.dp),
//                                    style = MaterialTheme.typography.bodySmall
//                                )
//                            }
//                        }
//
//                        Spacer(modifier = Modifier.height(8.dp))
//
//                        val listState = rememberLazyListState()
//
//                        LaunchedEffect(messageLog.size) {
//                            if (autoScroll && messageLog.isNotEmpty()) {
//                                listState.animateScrollToItem(messageLog.size - 1)
//                            }
//                        }
//
//                        LazyColumn(
//                            state = listState,
//                            modifier = Modifier
//                                .fillMaxWidth()
//                                .weight(1f)
//                                .border(
//                                    1.dp,
//                                    Color.White,
//                                    MaterialTheme.shapes.small
//                                )
//                                .padding(8.dp)
//                        ) {
//                            items(messageLog) { message ->
//                                MessageLogItem(message)
//                            }
//                        }
//                    }
//                }
//
//                // Bottom Actions
//                Row(
//
//                    modifier = Modifier.fillMaxWidth(),
//                    horizontalArrangement = Arrangement.SpaceBetween
//                ) {
//                    OutlinedButton(
//                        onClick = {
//                            scope.launch {
//                                messageLog.clear()
//                            }
//                        }
//                    ) {
//                        Text("Clear Log")
//                    }
//
//                    Button(
//                        onClick = {
//                            isReading = false
//                            showTableScreen = true
////                    sendAcknowledgePacket()
//                        },
//
//                        colors = ButtonDefaults.buttonColors(
//                            containerColor = MaterialTheme.colorScheme.primary,
//                        ),
//                        enabled = !showTableScreen && connectionState
//
//                    ) {
//                        Text(if(showTableScreen) "Close Table" else "Show Table")
//                    }
//
//                    Button(
//                        onClick = {
//                            scope.launch(Dispatchers.IO) {
//                                try {
//                                    bluetoothSocket?.close()
//                                    connectionState = !connectionState
//                                    messageLog.add("Disconnected from ${device.address}")
//
////                                    delay(3000)
//                                } catch (e: IOException) {
//                                    messageLog.add("Disconnection failed: ${e.message}")
//                                }
//                                onClose()
//                            }
//                        },
//                        colors = ButtonDefaults.buttonColors(
//                            containerColor = MaterialTheme.colorScheme.error
//                        )
//                    ) {
//                        Text("Disconnect")
//                    }
//                }
//            }
//        }
//
//
////        if(showTableScreen && activity != null){
////            Card(
////                modifier = Modifier.fillMaxWidth(),
////                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
////            ) {
////                TableScreen(device = device, onBack = { showTableScreen = false }, activity = activity)
////            }
////        }
//
//    }
//}
